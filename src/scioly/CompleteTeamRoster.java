package scioly;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Objects;

import scioly.FullTeamRoster.EventAssignment;
import scioly.Team.TeamMember;
import scioly.Tournament.TournamentEvent;

/**
 * 
 * CompleteTeamRoster
 * Represents a complete roster, containing all person-team-event assignments required to represent the roster. A CompleteTeamRoster can
 * be generated by traversing the FullTeamRoster tree to the root.
 * 
 * @author jason
 *
 */
public class CompleteTeamRoster {

	private TeamRosterConfiguration configuration;
	private CompleteTeamRosterTeam[] teams;
	private ArrayList<TeamMember> members;

	public static CompleteTeamRoster reconstruct(TeamRosterConfiguration configuration, FullTeamRoster roster) {
		CompleteTeamRoster ctr = new CompleteTeamRoster(configuration);
		FullTeamRoster current = roster;
		while (current != null) {
			EventAssignment assignment = current.getAssignment();
			if (assignment != null && assignment.getTeamIndex() >= 0) {
				ctr.assignMember(assignment.getTeamIndex(), assignment.getMember());
				for (TournamentEvent event : assignment.getEvents())
					ctr.assignMemberEvent(assignment.getTeamIndex(), assignment.getMember(), event);
			}
			current = current.getParent();
		}
		return ctr;
	}

	public CompleteTeamRoster(TeamRosterConfiguration configuration) {
		this.configuration = configuration;
		teams = new CompleteTeamRosterTeam[configuration.getTeamSizes().length];
		for (int i = 0; i < teams.length; i++)
			teams[i] = new CompleteTeamRosterTeam(configuration);
		members = new ArrayList<TeamMember>();
	}

	public void assignMember(int teamIndex, TeamMember member) {
		members.add(member);
		teams[teamIndex].assignMember(member);
	}

	public void assignMemberEvent(int teamIndex, TeamMember member, TournamentEvent event) {
		teams[teamIndex].assignMemberEvent(member, event);
	}

	public void print() {
		System.out.println(csv());
	}

	/**
	 * Outputs the roster as a csv table
	 * @return csv representation of the roster
	 */
	public String csv() {
		StringBuilder sb = new StringBuilder();
		ArrayList<TournamentEvent> sortedEvents = new ArrayList<TournamentEvent>(configuration.getTournament().getEvents());
		Collections.sort(sortedEvents, new Comparator<TournamentEvent>() {

			@Override
			public int compare(TournamentEvent o1, TournamentEvent o2) {
				return o1.getName().compareTo(o2.getName());
			}

		});

		int[] widths = new int[teams.length];
		for (int i = 0; i < widths.length; i++) {
			for (TournamentEvent event : configuration.getTournament().getEvents()) {
				if (teams[i].getEventMembers(event).size() > widths[i])
					widths[i] = teams[i].getEventMembers(event).size();
			}
		}

		sb.append(",");
		for (int i = 0; i < teams.length; i++) {
			sb.append("Team " + i);
			for (int j = 0; j < widths[i] + 1; j++)
				sb.append(",");
		}
		sb.append("\n");

		ArrayList<TournamentEvent> skippedHalves = new ArrayList<TournamentEvent>();

		for (TournamentEvent event : sortedEvents) {
			if (event.getName().contains(" - ")){
				boolean skipped = false;
				for (TournamentEvent e : skippedHalves){
					if (e.getName().startsWith(event.getName().split(" - ")[0]))
						skipped = true;
				}
				if (!skipped){
					skippedHalves.add(event);
					continue;
				}
			} else if (event.isBuilding())
				continue;

			sb.append(event.getName().split(" - ")[0] + ",");
			for (int teamIndex = 0; teamIndex < teams.length; teamIndex++){
				CompleteTeamRosterTeam team = teams[teamIndex];
				int k = 0;
				for (TeamMember person : team.getEventMembers(event)) {
					sb.append(person);
					sb.append(',');
					k++;
				}
				if (event.getName().contains(" - ")){
					TournamentEvent skippedHalf = null;
					for (TournamentEvent e : skippedHalves){
						if (e.getName().startsWith(event.getName().split(" - ")[0]))
							skippedHalf = e;
					}
					for (TeamMember person : team.getEventMembers(skippedHalf)) {
						sb.append(person);
						sb.append(',');
						k++;
					}
				}
				for (int i = 0; i < widths[teamIndex] - k + 1; i++){
					sb.append(',');
				}
			}
			sb.append('\n');
		}

		for (TournamentEvent event : sortedEvents){
			if (!event.isBuilding())
				continue;

			sb.append(event + ",");
			for (int teamIndex = 0; teamIndex < teams.length; teamIndex++){
				CompleteTeamRosterTeam team = teams[teamIndex];
				int k = 0;
				for (TeamMember person : team.getEventMembers(event)) {
					sb.append(person);
					sb.append(',');
					k++;
				}
				for (int i = 0; i < widths[teamIndex] - k + 1; i++){
					sb.append(',');
				}
			}
			sb.append('\n');
		}
		return sb.toString();
	}

	@Override
	public boolean equals(Object o) {

		if (o == this) return true;
		if (!(o instanceof CompleteTeamRoster)) {
			return false;
		}
		CompleteTeamRoster c = (CompleteTeamRoster) o;
		HashSet<CompleteTeamRosterTeam> teamSet = new HashSet<CompleteTeamRosterTeam>(Arrays.asList(teams));
		HashSet<CompleteTeamRosterTeam> otherTeamSet = new HashSet<CompleteTeamRosterTeam>(Arrays.asList(c.teams));
		return teamSet.equals(otherTeamSet);
	}

	@Override
	public int hashCode() {
		HashSet<CompleteTeamRosterTeam> teamSet = new HashSet<CompleteTeamRosterTeam>(Arrays.asList(teams));
		return teamSet.hashCode();
	}

	public static class CompleteTeamRosterTeam {

		private HashMap<TournamentEvent, HashSet<TeamMember>> events;
		private HashMap<TeamMember, HashSet<TournamentEvent>> people;

		public CompleteTeamRosterTeam(TeamRosterConfiguration configuration) {
			events = new HashMap<TournamentEvent, HashSet<TeamMember>>();
			people = new HashMap<TeamMember, HashSet<TournamentEvent>>();

			for (TournamentEvent event : configuration.getTournament().getEvents())
				events.put(event, new HashSet<TeamMember>());
		}

		public void assignMember(TeamMember member) {
			people.put(member, new HashSet<TournamentEvent>());
		}

		public void assignMemberEvent(TeamMember member, TournamentEvent event) {
			events.get(event).add(member);
			people.get(member).add(event);
		}

		public HashSet<TeamMember> getEventMembers(TournamentEvent event){
			return events.get(event);
		}

		public void print() {
			System.out.println(people);
		}

		@Override
		public boolean equals(Object o) {

			if (o == this) return true;
			if (!(o instanceof CompleteTeamRosterTeam)) {
				return false;
			}
			CompleteTeamRosterTeam c = (CompleteTeamRosterTeam) o;
			return events.equals(c.events) && people.equals(c.people);
		}

		@Override
		public int hashCode() {
			return Objects.hash(events, people);
		}

	}

}
